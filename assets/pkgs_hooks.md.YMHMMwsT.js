import{_ as t,c as e,o,ax as a}from"./chunks/framework.DSrT5G2K.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pkgs/hooks.md","filePath":"pkgs/hooks.md","lastUpdated":1752224702000}'),s={name:"pkgs/hooks.md"},r=a('<p><a href="./">Home</a> &gt; <a href="./hooks.html">@jview/hooks</a></p><h2 id="hooks-package" tabindex="-1">hooks package <a class="header-anchor" href="#hooks-package" aria-label="Permalink to &quot;hooks package&quot;">​</a></h2><p><code>@jview/hooks</code>封装了 JView UI 产品中常用的一些 Hooks，当然也不仅限于 JView UI 产品中使用。</p><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2><table><thead><tr><th><p>Function</p></th><th><p>Description</p></th></tr></thead><tbody><tr><td><p><a href="./hooks.useasyncloading.html">useAsyncLoading(fn)</a></p></td><td><p>你是否为一些异步状态的管理感到烦恼？如果答案是肯定的，那么 useAsyncLoading 一定是一剂良药。 useAsyncLoading 会包装函数 fn，并返回触发器和一些状态量，你可以通过触发器 trigger 来触发函数 fn 的执行，通过状态量 loading 来感知加载状态，这个 loading 可以绑定到按钮属性上，也可以作为一些判定的条件。 注意，fn 通常是异步的，比如返回一个 Promise，那么在 loading 状态下，再次调用 trigger 也不会重复触发 fn 的执行，这一点与 Button 组件的 loading 也有异曲同工之妙。</p></td></tr><tr><td><p><a href="./hooks.useelementcontentrect.html">useElementContentRect(options)</a></p></td><td><p>封装了计算 dom ContentRect 的 hook</p></td></tr><tr><td><p><a href="./hooks.usepickedprops.html">usePickedProps(props, keys)</a></p></td><td><p>从组件的 props 中挑选出部分属性，通常用于一些透传场景</p></td></tr><tr><td><p><a href="./hooks.useresizeobserver.html">useResizeObserver(options)</a></p></td><td><p>ResizeObserver hook，封装了一些便捷的逻辑</p></td></tr><tr><td><p><a href="./hooks.usewindowresize.html">useWindowResize(options)</a></p></td><td></td></tr></tbody></table><h2 id="interfaces" tabindex="-1">Interfaces <a class="header-anchor" href="#interfaces" aria-label="Permalink to &quot;Interfaces&quot;">​</a></h2><table><thead><tr><th><p>Interface</p></th><th><p>Description</p></th></tr></thead><tbody><tr><td><p><a href="./hooks.asyncloadingresponse.html">AsyncLoadingResponse</a></p></td><td><p>useAsyncLoading 的返回类型</p></td></tr><tr><td><p><a href="./hooks.useelementcontentrectoption.html">UseElementContentRectOption</a></p></td><td><p>useElementContentRect 选项</p></td></tr><tr><td><p><a href="./hooks.useresizeobserveroption.html">UseResizeObserverOption</a></p></td><td><p>useResizeObserver 的入参类型</p></td></tr></tbody></table><h2 id="type-aliases" tabindex="-1">Type Aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type Aliases&quot;">​</a></h2><table><thead><tr><th><p>Type Alias</p></th><th><p>Description</p></th></tr></thead><tbody><tr><td><p><a href="./hooks.domrectdata.html">DOMRectData</a></p></td><td><p>DOMRect</p></td></tr><tr><td><p><a href="./hooks.usewindowresizeoption.html">UseWindowResizeOption</a></p></td><td></td></tr></tbody></table>',9),n=[r];function d(p,h,i,c,l,k){return o(),e("div",null,n)}const m=t(s,[["render",d]]);export{f as __pageData,m as default};
